define(["./when-54c2dc71","./Cartesian2-49b1de22","./arrayRemoveDuplicates-216006b0","./BoundingRectangle-95b9a92c","./Transforms-e9dbfb40","./ComponentDatatype-6d99a1ee","./PolylineVolumeGeometryLibrary-8f28f929","./Check-6c0211bc","./GeometryAttribute-669569db","./GeometryAttributes-4fcfcf40","./GeometryPipeline-39e647e8","./IndexDatatype-46306178","./Math-44e92d6b","./PolygonPipeline-72c97573","./VertexFormat-7572c785","./RuntimeError-2109023a","./WebGLConstants-76bb35d1","./EllipsoidTangentPlane-c4704d0f","./IntersectionTests-6ead8677","./Plane-8f7e53d1","./PolylinePipeline-eb80587e","./EllipsoidGeodesic-a2d57ae0","./EllipsoidRhumbLine-9b557f71","./AttributeCompression-8ecc041c","./EncodedCartesian3-7ff81df8"],(function(e,t,n,i,r,a,o,l,s,p,d,c,u,g,y,m,h,f,b,v,E,P,_,x,k){"use strict";var C={};function V(t,n){e.defined(C[t])||(C[t]=!0,console.warn(e.defaultValue(n,t)))}function L(n){var i=(n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT)).polylinePositions,r=n.shapePositions;this._positions=i,this._shape=r,this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(n.ellipsoid,t.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,o.CornerType.ROUNDED),this._vertexFormat=y.VertexFormat.clone(e.defaultValue(n.vertexFormat,y.VertexFormat.DEFAULT)),this._granularity=e.defaultValue(n.granularity,u.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry",i=1+i.length*t.Cartesian3.packedLength,i+=1+r.length*t.Cartesian2.packedLength,this.packedLength=i+t.Ellipsoid.packedLength+y.VertexFormat.packedLength+2}V.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",V.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",V.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",V.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored",L.pack=function(n,i,r){var a;r=e.defaultValue(r,0);var o=n._positions,l=o.length;for(i[r++]=l,a=0;a<l;++a,r+=t.Cartesian3.packedLength)t.Cartesian3.pack(o[a],i,r);var s=n._shape;for(l=s.length,i[r++]=l,a=0;a<l;++a,r+=t.Cartesian2.packedLength)t.Cartesian2.pack(s[a],i,r);return t.Ellipsoid.pack(n._ellipsoid,i,r),r+=t.Ellipsoid.packedLength,y.VertexFormat.pack(n._vertexFormat,i,r),r+=y.VertexFormat.packedLength,i[r++]=n._cornerType,i[r]=n._granularity,i};var w=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),F=new y.VertexFormat,T={polylinePositions:void 0,shapePositions:void 0,ellipsoid:w,vertexFormat:F,cornerType:void 0,granularity:void 0};L.unpack=function(n,i,r){i=e.defaultValue(i,0);for(var a=n[i++],o=new Array(a),l=0;l<a;++l,i+=t.Cartesian3.packedLength)o[l]=t.Cartesian3.unpack(n,i);a=n[i++];var s=new Array(a);for(l=0;l<a;++l,i+=t.Cartesian2.packedLength)s[l]=t.Cartesian2.unpack(n,i);var p=t.Ellipsoid.unpack(n,i,w);i+=t.Ellipsoid.packedLength;var d=y.VertexFormat.unpack(n,i,F);i+=y.VertexFormat.packedLength;var c=n[i++],u=n[i];return e.defined(r)?(r._positions=o,r._shape=s,r._ellipsoid=t.Ellipsoid.clone(p,r._ellipsoid),r._vertexFormat=y.VertexFormat.clone(d,r._vertexFormat),r._cornerType=c,r._granularity=u,r):(T.polylinePositions=o,T.shapePositions=s,T.cornerType=c,T.granularity=u,new L(T))};var G=new i.BoundingRectangle;return L.createGeometry=function(e){var l=e._positions,u=n.arrayRemoveDuplicates(l,t.Cartesian3.equalsEpsilon),y=e._shape;if(y=o.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(y),!(u.length<2||y.length<3))return g.PolygonPipeline.computeWindingOrder2D(y)===g.WindingOrder.CLOCKWISE&&y.reverse(),l=i.BoundingRectangle.fromPoints(y,G),function(e,t,n,i){var o=new p.GeometryAttributes;i.position&&(o.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));var l,u,y,m,h,f=t.length,b=e.length/3,v=(b-2*f)/(2*f),E=g.PolygonPipeline.triangulate(t),P=(v-1)*f*6+2*E.length,_=c.IndexDatatype.createTypedArray(b,P),x=2*f,k=0;for(R=0;R<v-1;R++){for(l=0;l<f-1;l++)h=(u=2*l+R*f*2)+x,m=(y=u+1)+x,_[k++]=y,_[k++]=u,_[k++]=m,_[k++]=m,_[k++]=u,_[k++]=h;m=(y=1+(u=2*f-2+R*f*2))+x,h=u+x,_[k++]=y,_[k++]=u,_[k++]=m,_[k++]=m,_[k++]=u,_[k++]=h}if(i.st||i.tangent||i.bitangent){for(var C,L,w=new Float32Array(2*b),F=1/(v-1),T=1/n.height,G=n.height/2,A=0,R=0;R<v;R++){for(C=R*F,L=T*(t[0].y+G),w[A++]=C,w[A++]=L,l=1;l<f;l++)L=T*(t[l].y+G),w[A++]=C,w[A++]=L,w[A++]=C,w[A++]=L;L=T*(t[0].y+G),w[A++]=C,w[A++]=L}for(l=0;l<f;l++)C=0,L=T*(t[l].y+G),w[A++]=C,w[A++]=L;for(l=0;l<f;l++)C=(v-1)*F,L=T*(t[l].y+G),w[A++]=C,w[A++]=L;o.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(w)})}var D=b-2*f;for(R=0;R<E.length;R+=3){var I=E[R]+D,O=E[R+1]+D,S=E[R+2]+D;_[k++]=I,_[k++]=O,_[k++]=S,_[k++]=S+f,_[k++]=O+f,_[k++]=I+f}var B=new s.Geometry({attributes:o,indices:_,boundingSphere:r.BoundingSphere.fromVertices(e),primitiveType:s.PrimitiveType.TRIANGLES});if(i.normal&&(B=d.GeometryPipeline.computeNormal(B)),i.tangent||i.bitangent){try{B=d.GeometryPipeline.computeTangentAndBitangent(B)}catch(e){V("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(B.attributes.tangent=void 0),i.bitangent||(B.attributes.bitangent=void 0),i.st||(B.attributes.st=void 0)}return B}(o.PolylineVolumeGeometryLibrary.computePositions(u,y,l,e,!0),y,l,e._vertexFormat)},function(n,i){return(n=e.defined(i)?L.unpack(n,i):n)._ellipsoid=t.Ellipsoid.clone(n._ellipsoid),L.createGeometry(n)}}));